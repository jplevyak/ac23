#!/usr/bin/python3

t = 0
for l in open("1", "r").readlines():
    d = list(filter(str.isdigit, l))
    t += int(d[0] + d[-1])
print('1a', t)

t = 0
n = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
for l in open("1", "r").readlines():
    for nn in n:
        l = l.replace(nn, nn[:1] + str(n.index(nn) + 1) + nn[2:])
    d = list(filter(str.isdigit, l))
    t += int(d[0] + d[-1])
print('1b', t)

t = 0
n = { 'r' : 12, 'g' : 13, 'b' : 14 }
for l in open("2", "r").readlines():
    l = l.split(':')
    i = int(l[0].split()[1])
    pp = l[1].split(';')
    for p in pp:
        cc = p.split(',')
        for c in cc:
            v = c.strip().split()
            if int(v[0]) > n[v[1][0]]:
                i = 0
    t += i
print('2a', t)

t = 0
for l in open("2", "r").readlines():
    l = l.split(':')
    i = int(l[0].split()[1])
    pp = l[1].split(';')
    n = { 'r' : 0, 'g' : 0, 'b' : 0 }
    for p in pp:
        cc = p.split(',')
        for c in cc:
            v = c.strip().split()
            n[v[1][0]] = max(int(v[0]), n[v[1][0]])
    t += n['r'] * n['g'] * n['b']
print('2b', t)

t = 0
b = []
b.append('.' * 256)
for l in open("3", "r").readlines():
    b.append('.' + l.strip()+ '.')
b.append('.' * 256)

def issym(c):
    return c != '.' and not c.isdigit()

oo = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
found = False
for l in range(1, len(b)-1):
    i = 1
    while i < len(b[l]):
        if not b[l][i].isdigit():
            i += 1
            continue
        s = i
        while b[l][i].isdigit():
            for o in oo:
                if issym(b[l + o[0]][i + o[1]]):
                    found = True
            i += 1
        if found:
            t += int(b[l][s:i])
            found = False
print('3a', t)

t = 0
from collections import defaultdict
g = defaultdict(set)
found = set()
for l in range(1, len(b)-1):
    i = 1
    while i < len(b[l]):
        if not b[l][i].isdigit():
            i += 1
            continue
        s = i
        while b[l][i].isdigit():
            for o in oo:
                if b[l + o[0]][i + o[1]] == '*':
                    found.add((l + o[0], i + o[1]))
            i += 1
        for f in found:
            v = (l, s, int(b[l][s:i]))
            g[f].add((l, s, int(b[l][s:i])))
            found = set()
for _, v in g.items():
    v = list(v)
    if len(v) == 2:
        t += v[0][2] * v[1][2]
print('3b', t)

t = 0
for l in open("4", "r").readlines():
    l = l.split(':')[1].split('|')
    w = set(l[0].strip().split()).intersection(set(l[1].strip().split()))
    if len(w) > 0:
        t += 2 ** (len(w) - 1)
print('4a', t)

t = 0
c = [1] * 1000
for i, l in enumerate(open("4", "r").readlines()):
    l = l.split(':')[1].split('|')
    w = set(l[0].strip().split()).intersection(set(l[1].strip().split()))
    for x in range(1, len(list(w)) + 1):
        c[i + x] += c[i]
    t += c[i]
print('4b', t)

ll = list(open("5", "r").readlines())
ss = list(map(int, ll[0].split(':')[1].split()))
#mm = [[]]
mm = []
mi = 0
i = 1
while i < len(ll):
    i += 1
    if ll[i-1].find(':') != -1:
        continue
    if ll[i-1].strip() == '':
        mi += 1
        mm.append([])
        continue
    mm[mi-1].append(list(map(int, ll[i-1].split())))
l = 10000000000000000000
for s in ss:
    p = s
    for m in mm:
        for e in m:
            if p >= e[1] and p < e[1] + e[2]:
                p = e[0] + (p - e[1])
                break
    l = min(p, l)
print('5a', l)

def f(s, l, i, j, b):
    if i >= len(mm):
        return s
    if l <= 0 or j >= len(mm[i]):
        return b
    e = mm[i][j]
    if s >= e[1] and s < e[1] + e[2]:
        o = s - e[1]
        b = min(f(e[0] + o, min(l, e[2] - o), i + 1, 0, b), b)
    elif s < e[1] and s + l > e[1]:
        b = min(f(e[0], min(l - e[1] + s, e[2]), i + 1, 0, b), b)
    return min(b, f(s, l, i, j + 1, b))

b = 10000000000000000000
for p in range(int(len(ss)/2)):
    b = min(f(ss[p * 2], ss[p * 2 + 1], 0, 0, b), b)
print('5b', b)

ll = list(open("6", "r").readlines())
tt = list(map(int, ll[0].split(':')[1].split()))
dd = list(map(int, ll[1].split(':')[1].split()))

n = 1
for i in range(len(tt)):
    nn = 0
    for t in range(tt[i]):
        if t * (tt[i] - t) > dd[i]:
            nn += 1
    n *= nn
print('6a', n)

tt = int(ll[0].split(':')[1].replace(' ', ''))
dd = int(ll[1].split(':')[1].replace(' ', ''))

def f(low, high):
    if high >= low:
        mid = (high + low) // 2
        if mid * (tt - mid) == dd:
            return mid
        elif mid * (tt - mid) > dd:
            return f(low, mid - 1)
        else:
            return f(mid + 1, high)
    else:
        return high
m = f(0, tt)
print('6b', ((tt // 2) - m) * 2)

ll = list(map(lambda x: x.strip().split(), open("7", "r").readlines()))
v = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2']
for l in ll:
    l[0] = ''.join(list(map(lambda a: chr(ord('A') + (13 - v.index(a))), l[0])))
    l.append(''.join(sorted(l[0])))
    if l[2][0] == l[2][4]:
        r = 6
    elif l[2][0] == l[2][3] or l[2][1] == l[2][4]:
        r = 5
    elif len(set(list(l[2]))) == 2:  # full house
        r = 4
    elif len(set(list(l[2]))) == 3:  # 3 of a kind or 2 pair
        if l[2][0] == l[2][2] or l[2][1] == l[2][3] or l[2][2] == l[2][4]:
            r = 3
        else:
            r = 2
    elif len(set(list(l[2]))) == 4:  # one pair
        r = 1
    else:
        r = 0
    l.append(r)
s = sorted(ll, key=lambda x: (x[3], x[0]))
t = 0
for r, x in enumerate(s):
    t += (r + 1) * int(x[1])
print('7a', t)

from itertools import groupby
ll = list(map(lambda x: x.strip().split(), open("7", "r").readlines()))
v = ['A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J']
for l in ll:
    l[0] = ''.join(list(map(lambda a: chr(ord('A') + (12 - v.index(a))), l[0])))
    l.append(''.join(filter(('A').__ne__, sorted(l[0]))))
    c = []
    for k, g in groupby(l[2]):
        c.append((k, len(list(g))))
    if len(c) <= 1:
        r = 6  # 5 of a kind
    elif len(c) == 2:
        if c[0][1] == 1 or c[1][1] == 1:
            r = 5  # 4 of a kind
        else:
            r = 4 # full house
    elif len(c) == 3:
        if (5 - len((l[2]))) == 2 or ((5 - len((l[2]))) == 1 and (c[0][1] == 2 or c[1][1] == 2 or c[2][1] == 2)) or c[0][1] == 3 or c[1][1] == 3 or c[2][  1] == 3:
            r = 3 # 3 of a kind
        else:
            r = 2 # 2 pair
    elif len(c) == 4:  # one pair
        r = 1
    else:
        r = 0
    l.append(r)
s = sorted(ll, key=lambda x: (x[3], x[0]))
t = 0
for r, x in enumerate(s):
    t += (r + 1) * int(x[1])
print('7b', t)

ll = list(map(lambda x: x.strip(), open("8", "r").readlines()))
m = ll[0]
g = {}
for l in ll[2:]:
    g[l[0:3]] = (l[7:10], l[12:15])
s = 'AAA'
i = 0
while s != 'ZZZ':
    i += 1
    s = g[s][0 if m[(i - 1) % len(m)] == 'L' else 1]
print('8a', i)

i = 0
s = list(filter(lambda x : x[2] == 'A', g.keys()))
ss = [set() for _ in range(len(s))]
pp = [[] for _ in range(len(s))]
nn = [0 for _ in range(len(s))]
done = set()
for k, x in enumerate(s):
    pp[k].append(x)
while len(done) < len(s) and len(list(filter(lambda x : x[2] != 'Z', s))) != 0:
    i += 1
    d = 0 if m[(i - 1) % len(m)] == 'L' else 1
    s = list(map(lambda x : g[x][d], s))
    for k, x in enumerate(s):
        pp[k].append(x)
    sn = []
    for k, x in enumerate(s):
        if not k in done and (x, i % len(m)) in ss[k]:
            print('cycle', k, i, x, pp[k].index(x), i - pp[k].index(x), len(pp[k]));
            nn[k] = i - pp[k].index(x)
            for q, v in enumerate(pp[k]):
                if v[2] == 'Z':
                    print(v, q)
            done.add(k)
        sn.append(x)
        ss[k].add((x, i % len(m)))
    s = sn
import math
print('8b', math.lcm(*nn))
